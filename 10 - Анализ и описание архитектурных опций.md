# 1. Анализ и описание архитектурных опций

## 1. Монолитная архитектура vs. Микросервисы

### 1.1. Монолитная архитектура

**Описание**

- Всё приложение разворачивается в виде единого исполняемого модуля или монолитного веб-приложения.
- Вся логика (регистрация пользователей, учёт тренировок, социальная лента, геймификация и т.п.) находится в одном кодовом репозитории.

**Плюсы**

1. Проще начать разработку (особенно для MVP): одна база данных, единые пайплайны сборки.
2. Легче вести отладку на начальном этапе, поскольку нет сложных распределённых взаимосвязей.
3. Меньше сложностей с DevOps: один деплой, одна точка масштабирования.

**Минусы**

1. Ограниченные возможности масштабирования: при росте нагрузки приходится масштабировать весь монолит целиком.
2. Сложность развития: со временем кодовая база становится громоздкой; при добавлении новых функций велик риск ломать уже существующие модули.
3. Сложность внедрения новых технологий: если требуется, например, отдельная БД для модуля аналитики, приходится перестраивать часть всего монолита.

**Вывод**

- Монолит может быть хорош для быстрого старта, но при серьёзном росте аудитории (тысячи/десятки тысяч пользователей одновременно) и необходимости глобальной экспансии такая архитектура быстро превратится в «бутылочное горлышко».

### 1.2. Микросервисная архитектура

**Описание**

- Приложение разбивается на набор небольших автономных сервисов (User Management, Workout & Activity, Social & Group, Gamification и т.д.).
- Каждый сервис может использовать свою БД или подходящую модель данных.

**Плюсы**

1. **Горизонтальное масштабирование** отдельных сервисов (например, если Social & Group испытывает особую нагрузку, можно масштабировать только его).
2. **Гибкость разработки**: разные команды могут работать над разными сервисами, выбирая наиболее подходящие технологии.
3. **Устойчивость**: сбой в одном сервисе не парализует всё приложение (если правильно реализованы цепочки вызовов и fallback-механизмы).

**Минусы**

1. **Высокая сложность**: нужно выстроить чёткую систему DevOps, мониторинга, логирования, управления конфигурацией.
2. **Увеличение сетевых взаимодействий**: микросервисы общаются между собой по сети, что влечёт дополнительную задержку и риск сетевых сбоев.
3. **Разнесённая логика**: нужно тщательно проектировать API и контракты между сервисами.

**Вывод**

- Микросервисы идеальны для масштабируемых распределённых систем, которые предполагают добавление функционала, высокую нагрузку и глобальное развитие. Но требуют серьёзных инвестиций в инфраструктуру и квалификацию команды.

## 2. Селектор технологического стека и облачная стратегия

### 2.1. Облачная или локальная инфраструктура?

**1. Публичное облако (AWS, Azure, GCP)**

- Быстрое масштабирование, глобальная доступность, готовые сервисы (базы данных, очереди, IoT-hub, сервисы машинного обучения).
- Минусы: возможная зависимость от провайдера (vendor lock-in), стоимость.

**2. Собственная локальная инфраструктура (on-premise)**

- Полный контроль над серверами, удобнее решать некоторые вопросы комплаенса (например, хранение данных в физически обособленном месте).
- Минусы: сложность масштабирования, крупные капитальные вложения, нужно самостоятельно поддерживать доступность.

**3. Гибридное решение**

- Часть сервисов в публичном облаке, часть — локально (или в другом провайдере).
- Гибкий баланс между контролем над данными и скоростью развития.

**Вывод**

- С учётом глобальности приложения, необходимости в быстрых экспериментах и отсутствии «единого» провайдера внутри компании, наиболее целесообразен **мультиоблачный или гибридный подход** с использованием Kubernetes/Terraform для управления инфраструктурой.

### 2.2. Выбор моделей данных (SQL vs. NoSQL vs. Time Series)

**1. Реляционные БД (PostgreSQL, MySQL, MS SQL)**

- Удобны для транзакционной логики, хранения учётных записей, заказов, промоакций.
- Простые и понятные механизмы JOIN, согласованность данных.

**2. NoSQL (MongoDB, DynamoDB, Cassandra)**

- Высокая производительность при записи больших объёмов «плоских» данных: лента активности, метрики тренировок.
- Гибкая схема (позволяет быстро добавлять новые поля и структуры).

**3. Time Series DB (InfluxDB, TimescaleDB)**

- Специализированные решения для временных рядов (пульс, шаги, температурные датчики), удобные инструменты агрегации и фильтрации по времени.

**Вывод**

- **Гибридная модель хранения**: реляционная БД для ключевых транзакций (User Profile, заказы), NoSQL для социальной ленты и объёмных записей тренировок, Time Series — для обработки телеметрии в реальном времени.

### 2.3. Подход к обмену сообщениями (REST, gRPC, событийная шина)

**1. REST/HTTP**

- Дефакто стандарт для веб-приложений, широкая поддержка.
- Может быть медленнее и «потяжелее» для высокочастотного обмена.

**2. gRPC**

- Быстрый бинарный протокол, удобен при частых вызовах между микросервисами.
- Требует чуть большей квалификации от команды и наличия protobuf-схем.

**3. Event-driven (шины/очереди: Kafka, RabbitMQ, Pulsar)**

- Асинхронная модель, повышает надёжность и масштабируемость.
- Удобна для сбора данных от IoT, геймификации, стриминговой аналитики.

**Вывод**

- Оптимальное решение — **гибрид**: синхронные REST/gRPC-вызовы для запросов, требующих мгновенного отклика (например, данные о пользователе, авторизация), и **event-driven шина** (Kafka или RabbitMQ) для событий тренировок, активности и аналитики.

### 2.4. Выбор подхода к аналитике (Batch/Real-time, Big Data)

**1. Batch-аналитика (Spark/Hadoop)**

- Подходит для больших исторических данных (генерация отчётов за неделю, месяц).
- Менее оперативна (несколько часов/минут задержки).

**2. Стриминг (Kafka, Flink, Spark Streaming)**

- Позволяет обрабатывать события в реальном времени (мониторинг пульса, уведомления о достижениях).
- Важен для геймификации, лидербордов и рекомендаций «на лету».

**Вывод**

- Наилучший вариант — **комбинированная схема**: стриминговая обработка для оперативных сценариев, параллельно — batch для глобальной статистики, ML-моделей, ретроспективных отчётов.

### 2.5. Интеграция с внешними устройствами (IoT)

**1. Прямая интеграция (каждое устройство -> сервис)**

- Много точек входа, высокие риски несовместимости.
- Сложность масштабирования и обновлений.

**2. Шлюз (IoT Hub)**

- Унифицированный канал, где все устройства регистрируются и передают данные в единый endpoint.
- Возможность реализации адаптеров для разных протоколов и форматов данных.

**Вывод**

- **IoT Hub** или слой, аналогичный AWS IoT / Azure IoT Hub / Google IoT Core, где каждая категория устройств передаёт данные по защищённым протоколам, а уже затем данные стандартизируются и перенаправляются в нужные микросервисы.

### 2.6. Выбор архитектурного стиля: обоснование микросервисов

Учитывая следующие факторы:

1. **Сложность и многофункциональность** (регистрация, учёт тренировок, социальная лента, геймификация, промоакции, интеграция с магазином).
2. **Требования по масштабируемости** для мировой аудитории и массовых челленджей.
3. **Гибкое развитие** (регулярные обновления, выпуск новых версий сервисов без остановки всей системы).
4. **Наличие команды из многих разработчиков** (в том числе, распределённых по языкам/локализациям).

Всё это говорит в пользу **микросервисной архитектуры**.

**Ключевые обоснования**:

- Микросервисы легче поддерживать и развивать при быстро меняющихся требованиях — каждый сервис можно обновлять и релизить независимо.
- Проще адаптировать отдельные сервисы к локальным нормам (например, различный подход к хранению данных для определённой страны).
- Изолированные сервисы позволяют применять разные технологии (SQL, NoSQL, кэш) там, где это рациональнее.

### 2.7. Обоснование мультиязычной (multicloud) инфраструктуры

1. **Уже используемые облачные провайдеры** в компании.
2. **Минимизация рисков** из-за перебоев у одного конкретного провайдера, гибкая оптимизация стоимости.
3. **Различные инструменты** и готовые сервисы от каждого провайдера (например, GCP хорош для Big Data, AWS — для IoT, Azure — для enterprise-интеграций).

**Следствия**:

- Использование инструментов типа **Kubernetes** (K8s) для оркестрации контейнеров во всех облаках.
- Автоматизация инфраструктуры (Terraform, Ansible), чтобы унифицировать конфигурации.
- Проектирование системы с учётом сетевых задержек и распределения данных по регионам.

## 3. Итоговый выбор и ключевые обоснования

1. **Архитектурный стиль**: микросервисная архитектура.
   - Позволяет гибко масштабировать отдельные модули, ускоряет внедрение нового функционала и поддерживает многокомандную разработку.
2. **Облачная стратегия**: мультиоблако / гибридная модель.
   - Обеспечивает гибкость развертывания, отказоустойчивость при проблемах у одного провайдера.
   - Использование Kubernetes для оркестрации.
3. **Хранилища**: гибрид из реляционных (для критичных транзакций), NoSQL (для больших объёмов социальных данных), Time Series (для метрик тренировок).
   - Учитывает специфику данных: структурированные, неструктурированные, телеметрические потоки.
4. **Обмен данными**:
   - Синхронные вызовы (REST/gRPC) для критичного функционала (авторизация, быстрый доступ к данным пользователя).
   - Асинхронная шина сообщений (Kafka, RabbitMQ) для событий, логов, аналитики в реальном времени.
5. **IoT Hub** для единой интеграции с носимыми устройствами.
   - Упрощает масштабирование и добавление новых типов датчиков.
6. **Комбинированная аналитика** (Batch + Streaming).
   - Streaming для мгновенных уведомлений и игровых механик, Batch для глубоких отчётов и ML-моделей (Spark/Hadoop).
7. **Безопасность и приватность**:
   - Строгое соблюдение локальных требований (GDPR, HIPAA и т.д.), шифрование данных (TLS при передаче, AES-256 в покое), продвинутый IDM (OAuth2/OpenID Connect).

## Заключение

- **Микросервисная архитектура** в мультиоблачном окружении, с комплексным подходом к хранению (SQL + NoSQL + TSDB) и гибридной моделью аналитики, наиболее полно удовлетворяет бизнес-требования: высокую масштабируемость, распределённость, гибкость развития и внедрения новых фич.
- В основе решения лежит **IoT Hub** (для сторонних устройств), сервисная шина (Kafka/RabbitMQ) для событийной логики, а также **грамотная организация CI/CD** и системы управления конфигурацией (Terraform, Kubernetes).
- При этом необходима продуманная политика безопасности и приватности, чтобы соответствовать локальным законам и обеспечить доверие пользователей.

Таким образом, выбранный **архитектурный подход** даёт компании возможности для быстрых экспериментов, стабильного роста количества пользователей и интеграции с передовыми технологиями (машинное обучение, IoT, геймификация) без крупных рисков и «монолитных» ограничений.
